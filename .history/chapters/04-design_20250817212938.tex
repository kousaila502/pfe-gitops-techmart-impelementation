\chapter{System Design and Research Methodology}

\section{Introduction and Design Overview}

This chapter presents the comprehensive system design and research methodology implemented for the empirical comparison of GitOps and Traditional CI/CD methodologies through the TechMart multi-cloud e-commerce platform. The design encompasses both the technical architecture and the research framework necessary for conducting rigorous methodology evaluation while demonstrating production-grade DevOps implementation.

The system design addresses the dual requirements of providing a functional e-commerce platform while serving as a controlled research environment for methodology comparison. This dual-purpose approach ensures that findings reflect genuine production characteristics rather than artificial laboratory conditions, while maintaining the controlled variables necessary for valid scientific analysis.

The design methodology prioritizes authenticity, scalability, and observability to enable comprehensive data collection while demonstrating enterprise-grade DevOps practices across multiple cloud platforms. The architecture deliberately distributes services across different platforms to create realistic operational complexity while enabling direct methodology comparison under identical business requirements.

The research methodology framework provides systematic approaches for data collection, complexity normalization, and statistical analysis that enable valid conclusions about methodology performance characteristics. This framework accounts for service complexity variations, technology stack differences, and operational factors that could confound comparative analysis.

\section{Microservices Architecture Design}

\subsection{Core Services Architecture}

The TechMart platform implements a sophisticated microservices architecture comprising four core services plus an additional search service, each designed to demonstrate specific aspects of modern e-commerce functionality while enabling comprehensive methodology comparison. The service decomposition follows domain-driven design principles with clear business capability boundaries and technology diversity that reflects real-world enterprise environments.

% TODO: Add Figure 4.1 - Complete TechMart Microservices Architecture
\begin{figure}[H]
\centering
% Figure content to be added later
\caption{TechMart Multi-Cloud Microservices Architecture Overview}
\label{fig:techmart-architecture-overview}
\end{figure}

#### **User Service - Authentication and Profile Management**
The User Service represents the authentication backbone of the platform, implemented using Python FastAPI with Neon PostgreSQL to provide enterprise-grade user management capabilities. The service demonstrates advanced GitOps deployment patterns on Google Kubernetes Engine with ArgoCD orchestration, showcasing automated synchronization, self-healing, and declarative configuration management.

**Technical Specifications:**
- **Technology Stack**: Python FastAPI 0.104+, SQLAlchemy (Async), Neon PostgreSQL
- **Platform**: Google Kubernetes Engine (GitOps Deployment)
- **Port**: 9090
- **Database**: Dedicated Neon PostgreSQL instance with connection pooling
- **Authentication**: JWT token generation with bcrypt password hashing
- **Features**: User registration, authentication, profile management, role-based access control

**API Capabilities:**
- User registration with email and mobile validation
- JWT authentication with configurable token expiration (30 minutes)
- Role-based access control (User/Admin) with privilege separation
- Profile management with secure update mechanisms
- Administrative dashboard with user statistics and control functions
- Session management with IP tracking and concurrent session limits

#### **Order Service - Transaction Processing**
The Order Service manages the complete order lifecycle from cart checkout through fulfillment, implemented using Python FastAPI with dual database integration (PostgreSQL for transactional data and Redis for caching). The service demonstrates complex business logic implementation within GitOps deployment patterns while providing comprehensive integration with other platform services.

**Technical Specifications:**
- **Technology Stack**: Python FastAPI, SQLAlchemy (Async), PostgreSQL + Redis
- **Platform**: Google Kubernetes Engine (GitOps Deployment)
- **Port**: 8081
- **Databases**: Neon PostgreSQL (primary), Upstash Redis (caching)
- **Integration**: Multi-service connectivity with User, Cart, and Product services
- **Features**: Order processing, payment coordination, fulfillment tracking

**Business Capabilities:**
- Complete order lifecycle management from creation to fulfillment
- Multi-service integration for cart validation and product verification
- Payment processing coordination with external payment providers
- Order status tracking with real-time updates and notifications
- Administrative order management with status updates and analytics
- Revenue tracking and business intelligence reporting

#### **Product Service - Catalog Management**
The Product Service provides comprehensive product catalog management implemented using Node.js Express with MongoDB Atlas, demonstrating Traditional CI/CD deployment patterns on Heroku platform. The service showcases platform-as-a-service optimization while providing sophisticated product management capabilities including search, categorization, and inventory management.

**Technical Specifications:**
- **Technology Stack**: Node.js 18.x, Express.js 4.x, MongoDB Atlas
- **Platform**: Heroku Container Stack (Traditional CI/CD)
- **Port**: 3001
- **Database**: MongoDB Atlas with global replication
- **Repository**: Mongoose ODM with schema validation
- **Features**: Product CRUD, search capabilities, inventory management

**API Functionality:**
- Complete product management with CRUD operations and SKU tracking
- Advanced search capabilities with full-text indexing across multiple fields
- Category and department-based filtering with hierarchical organization
- Inventory management with stock tracking and low-stock alerts
- Deal and promotion management with time-based offers
- Analytics and reporting with product performance metrics

#### **Cart Service - Session Management**
The Cart Service implements high-performance shopping cart functionality using Java Spring Boot WebFlux with reactive programming patterns and Redis storage. The service demonstrates Traditional CI/CD deployment on Heroku while showcasing reactive architecture benefits including non-blocking I/O and backpressure management for optimal performance under load.

**Technical Specifications:**
- **Technology Stack**: Java 17, Spring Boot 2.7.1, Spring WebFlux, Upstash Redis
- **Platform**: Heroku Container Stack (Traditional CI/CD)
- **Port**: 8080
- **Storage**: Upstash Redis with reactive operations
- **Architecture**: Reactive programming with Mono/Flux streams
- **Features**: Real-time cart management, product validation, checkout preparation

**Reactive Capabilities:**
- Non-blocking cart operations with Spring WebFlux reactive streams
- Real-time product validation through reactive service integration
- High-performance Redis operations with connection pooling
- Automatic fallback mechanisms for service resilience
- JWT authentication integration with upstream user validation
- Reactive error handling and circuit breaker patterns

#### **Search Service - Advanced Discovery (Additional)**
The Search Service provides advanced product discovery capabilities implemented using Node.js with Elasticsearch integration, deployed on Render platform to demonstrate additional multi-cloud integration patterns. While not central to the GitOps comparison, this service enhances the platform's realism and provides additional operational complexity.

**Technical Specifications:**
- **Technology Stack**: Node.js Express, Elasticsearch (Bonsai)
- **Platform**: Render (Serverless Deployment)
- **Port**: 3000
- **Search Engine**: Bonsai Elasticsearch with full-text indexing
- **Features**: Advanced search, filters, recommendations

\subsection{Service Interconnection and Communication Design}

The microservices architecture implements sophisticated inter-service communication patterns that demonstrate enterprise-grade integration while maintaining service autonomy and operational independence. The communication design balances performance, reliability, and security requirements while enabling comprehensive observability for research data collection.

% TODO: Add Figure 4.2 - Service Communication Patterns and Integration Flow
\begin{figure}[H]
\centering
% Figure content to be added later
\caption{Inter-Service Communication Architecture and Data Flow}
\label{fig:service-communication-patterns}
\end{figure}

#### **Authentication Flow Architecture**
The authentication architecture implements a centralized JWT-based security model where the User Service serves as the primary authentication provider for all platform services. This design demonstrates secure multi-service authentication while maintaining stateless communication patterns essential for scalable microservices architectures.

**Authentication Sequence:**
1. **User Registration/Login** → User Service generates JWT token with user claims
2. **Token Propagation** → Client includes JWT in Authorization headers for all service requests
3. **Token Validation** → Each service validates JWT signature using shared secret
4. **Role Authorization** → Services enforce role-based access control based on JWT claims
5. **Cross-Service Calls** → Services propagate authentication context for chained operations

**Security Implementation:**
- JWT tokens with 30-minute expiration and automatic refresh mechanisms
- Shared secret key across all services for token validation consistency
- Role-based access control with User and Admin privilege levels
- CORS configuration enabling secure cross-origin requests from frontend
- Request/response logging for security audit trails and compliance

#### **Business Transaction Patterns**
The platform implements complex business transactions that span multiple services, demonstrating distributed transaction management and eventual consistency patterns essential for microservices architectures. These patterns showcase real-world operational complexity while providing meaningful data for methodology performance analysis.

**Order Processing Transaction Flow:**
1. **Cart Validation** → Cart Service validates items and calculates totals
2. **User Authentication** → User Service validates customer identity and permissions
3. **Product Verification** → Product Service confirms availability and pricing
4. **Order Creation** → Order Service creates transaction records and manages state
5. **Inventory Update** → Product Service updates stock levels and availability
6. **Payment Processing** → Order Service coordinates with external payment providers
7. **Fulfillment Initiation** → Order Service triggers shipping and tracking processes

**Data Consistency Management:**
- Event-driven architecture with service-to-service communication
- Compensating transaction patterns for rollback scenarios
- Eventual consistency models with conflict resolution strategies
- Distributed state management with service ownership boundaries
- Error handling and retry mechanisms for transaction resilience

\subsection{Authentication and Authorization Flow Design}

The authentication and authorization architecture implements a comprehensive security framework that demonstrates enterprise-grade identity management while supporting both user-facing and administrative operations. The design prioritizes security, usability, and operational efficiency while providing detailed audit capabilities for compliance and research analysis.

#### **JWT Implementation Architecture**
The JWT implementation provides stateless authentication that scales across multiple services and platforms while maintaining security and performance characteristics essential for distributed systems. The token structure includes comprehensive user information and role assignments that enable fine-grained authorization decisions.

**JWT Token Structure:**
```json
{
  "sub": "user_id_123",
  "email": "user@example.com", 
  "name": "John Doe",
  "role": "user|admin",
  "iat": 1692123456,
  "exp": 1692125256,
  "jti": "unique_token_id"
}
```

**Token Management Features:**
- Configurable expiration times balancing security with user experience
- Unique token identifiers (JTI) enabling token revocation and audit trails
- Role-based claims supporting hierarchical permission models
- Automatic token refresh mechanisms reducing authentication friction
- Secure token storage and transmission protocols

#### **Role-Based Access Control Design**
The RBAC implementation provides flexible permission management that supports both operational requirements and administrative functions while maintaining clear security boundaries between different user types and service capabilities.

**Permission Hierarchy:**
- **Public Access**: Service health checks, product browsing, user registration
- **Authenticated User**: Profile management, cart operations, order placement, order history
- **Administrative User**: User management, product management, order administration, system analytics
- **System Integration**: Inter-service communication, health monitoring, operational metrics

**Authorization Enforcement:**
- Endpoint-level authorization with role requirements clearly documented
- Service-level authorization for cross-service communication patterns
- Administrative function protection with enhanced logging and audit trails
- API documentation with authorization requirements for each endpoint

\subsection{User vs Admin Interface Architecture}

The platform architecture supports dual interfaces optimized for different user types and operational requirements, demonstrating sophisticated user experience design while maintaining consistent backend services and security models. This design showcases enterprise-grade application architecture with role-based user experience optimization.

#### **User Interface Architecture**
The user-facing interface prioritizes ease of use, performance, and conversion optimization while providing comprehensive e-commerce functionality through intuitive workflows and responsive design patterns.

**User Experience Features:**
- Product browsing and search with advanced filtering capabilities
- Shopping cart management with real-time updates and validation
- User registration and authentication with social login options
- Order placement with multiple payment methods and shipping options
- Order tracking with real-time status updates and notifications
- Profile management with personal information and preference settings

#### **Administrative Interface Architecture**
The administrative interface provides comprehensive platform management capabilities optimized for operational efficiency and business intelligence while maintaining security and audit compliance.

**Administrative Capabilities:**
- User management dashboard with registration analytics and user control
- Product catalog management with inventory tracking and promotional tools
- Order management system with status updates and fulfillment coordination
- Business analytics with revenue tracking and performance metrics
- System monitoring with service health and operational metrics
- Security management with access control and audit trail review

% TODO: Add Table 4.1 - Service Capabilities and Interface Access Matrix
\begin{table}[H]
\centering
\caption{Service Capabilities and User Interface Access Matrix}
\label{tab:service-capabilities-matrix}
% Table content to be added later
\end{table}







