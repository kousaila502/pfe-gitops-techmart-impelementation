\chapter{System Design and Research Methodology}

\section{Introduction and Design Overview}

This chapter presents the comprehensive system design and research methodology implemented for the empirical comparison of GitOps and Traditional CI/CD methodologies through the TechMart multi-cloud e-commerce platform. The design encompasses both the technical architecture and the research framework necessary for conducting rigorous methodology evaluation while demonstrating production-grade DevOps implementation.

The system design addresses the dual requirements of providing a functional e-commerce platform while serving as a controlled research environment for methodology comparison. This dual-purpose approach ensures that findings reflect genuine production characteristics rather than artificial laboratory conditions, while maintaining the controlled variables necessary for valid scientific analysis.

The design methodology prioritizes authenticity, scalability, and observability to enable comprehensive data collection while demonstrating enterprise-grade DevOps practices across multiple cloud platforms. The architecture deliberately distributes services across different platforms to create realistic operational complexity while enabling direct methodology comparison under identical business requirements.

The research methodology framework provides systematic approaches for data collection, complexity normalization, and statistical analysis that enable valid conclusions about methodology performance characteristics. This framework accounts for service complexity variations, technology stack differences, and operational factors that could confound comparative analysis.

\section{Microservices Architecture Design}

\subsection{Core Services Architecture}

The TechMart platform implements a sophisticated microservices architecture comprising four core services plus an additional search service, each designed to demonstrate specific aspects of modern e-commerce functionality while enabling comprehensive methodology comparison. The service decomposition follows domain-driven design principles with clear business capability boundaries and technology diversity that reflects real-world enterprise environments.

% TODO: Add Figure 4.1 - Complete TechMart Microservices Architecture
\begin{figure}[H]
\centering
% Figure content to be added later
\caption{TechMart Multi-Cloud Microservices Architecture Overview}
\label{fig:techmart-architecture-overview}
\end{figure}

\subsubsection{User Service - Authentication and Profile Management}

The User Service represents the authentication backbone of the platform, implemented using Python FastAPI with Neon PostgreSQL to provide enterprise-grade user management capabilities. The service demonstrates advanced GitOps deployment patterns on Google Kubernetes Engine with ArgoCD orchestration, showcasing automated synchronization, self-healing, and declarative configuration management.

\textbf{Technical Specifications:}
\begin{itemize}
\item Technology Stack: Python FastAPI 0.104+, SQLAlchemy (Async), Neon PostgreSQL
\item Platform: Google Kubernetes Engine (GitOps Deployment)
\item Port: 9090
\item Database: Dedicated Neon PostgreSQL instance with connection pooling
\item Authentication: JWT token generation with bcrypt password hashing
\item Features: User registration, authentication, profile management, role-based access control
\end{itemize}

\textbf{API Capabilities:}
\begin{itemize}
\item User registration with email and mobile validation
\item JWT authentication with configurable token expiration (30 minutes)
\item Role-based access control (User/Admin) with privilege separation
\item Profile management with secure update mechanisms
\item Administrative dashboard with user statistics and control functions
\item Session management with IP tracking and concurrent session limits
\end{itemize}

\subsubsection{Order Service - Transaction Processing}

The Order Service manages the complete order lifecycle from cart checkout through fulfillment, implemented using Python FastAPI with dual database integration (PostgreSQL for transactional data and Redis for caching). The service demonstrates complex business logic implementation within GitOps deployment patterns while providing comprehensive integration with other platform services.

\textbf{Technical Specifications:}
\begin{itemize}
\item Technology Stack: Python FastAPI, SQLAlchemy (Async), PostgreSQL + Redis
\item Platform: Google Kubernetes Engine (GitOps Deployment)
\item Port: 8081
\item Databases: Neon PostgreSQL (primary), Upstash Redis (caching)
\item Integration: Multi-service connectivity with User, Cart, and Product services
\item Features: Order processing, payment coordination, fulfillment tracking
\end{itemize}

\textbf{Business Capabilities:}
\begin{itemize}
\item Complete order lifecycle management from creation to fulfillment
\item Multi-service integration for cart validation and product verification
\item Payment processing coordination with external payment providers
\item Order status tracking with real-time updates and notifications
\item Administrative order management with status updates and analytics
\item Revenue tracking and business intelligence reporting
\end{itemize}

\subsubsection{Product Service - Catalog Management}

The Product Service provides comprehensive product catalog management implemented using Node.js Express with MongoDB Atlas, demonstrating Traditional CI/CD deployment patterns on Heroku platform. The service showcases platform-as-a-service optimization while providing sophisticated product management capabilities including search, categorization, and inventory management.

\textbf{Technical Specifications:}
\begin{itemize}
\item Technology Stack: Node.js 18.x, Express.js 4.x, MongoDB Atlas
\item Platform: Heroku Container Stack (Traditional CI/CD)
\item Port: 3001
\item Database: MongoDB Atlas with global replication
\item Repository: Mongoose ODM with schema validation
\item Features: Product CRUD, search capabilities, inventory management
\end{itemize}

\textbf{API Functionality:}
\begin{itemize}
\item Complete product management with CRUD operations and SKU tracking
\item Advanced search capabilities with full-text indexing across multiple fields
\item Category and department-based filtering with hierarchical organization
\item Inventory management with stock tracking and low-stock alerts
\item Deal and promotion management with time-based offers
\item Analytics and reporting with product performance metrics
\end{itemize}

\subsubsection{Cart Service - Session Management}

The Cart Service implements high-performance shopping cart functionality using Java Spring Boot WebFlux with reactive programming patterns and Redis storage. The service demonstrates Traditional CI/CD deployment on Heroku while showcasing reactive architecture benefits including non-blocking I/O and backpressure management for optimal performance under load.

\textbf{Technical Specifications:}
\begin{itemize}
\item Technology Stack: Java 17, Spring Boot 2.7.1, Spring WebFlux, Upstash Redis
\item Platform: Heroku Container Stack (Traditional CI/CD)
\item Port: 8080
\item Storage: Upstash Redis with reactive operations
\item Architecture: Reactive programming with Mono/Flux streams
\item Features: Real-time cart management, product validation, checkout preparation
\end{itemize}

\textbf{Reactive Capabilities:}
\begin{itemize}
\item Non-blocking cart operations with Spring WebFlux reactive streams
\item Real-time product validation through reactive service integration
\item High-performance Redis operations with connection pooling
\item Automatic fallback mechanisms for service resilience
\item JWT authentication integration with upstream user validation
\item Reactive error handling and circuit breaker patterns
\end{itemize}

\subsubsection{Search Service - Advanced Discovery}

The Search Service provides advanced product discovery capabilities implemented using Node.js with Elasticsearch integration, deployed on Render platform to demonstrate additional multi-cloud integration patterns. While not central to the GitOps comparison, this service enhances the platform's realism and provides additional operational complexity.

\textbf{Technical Specifications:}
\begin{itemize}
\item Technology Stack: Node.js Express, Elasticsearch (Bonsai)
\item Platform: Render (Serverless Deployment)
\item Port: 3000
\item Search Engine: Bonsai Elasticsearch with full-text indexing
\item Features: Advanced search, filters, recommendations
\end{itemize}

\subsection{Service Interconnection and Communication Design}

The microservices architecture implements sophisticated inter-service communication patterns that demonstrate enterprise-grade integration while maintaining service autonomy and operational independence. The communication design balances performance, reliability, and security requirements while enabling comprehensive observability for research data collection.

% TODO: Add Figure 4.2 - Service Communication Patterns and Integration Flow
\begin{figure}[H]
\centering
% Figure content to be added later
\caption{Inter-Service Communication Architecture and Data Flow}
\label{fig:service-communication-patterns}
\end{figure}

\subsubsection{Authentication Flow Architecture}

The authentication architecture implements a centralized JWT-based security model where the User Service serves as the primary authentication provider for all platform services. This design demonstrates secure multi-service authentication while maintaining stateless communication patterns essential for scalable microservices architectures.

\textbf{Authentication Sequence:}
\begin{enumerate}
\item User Registration/Login: User Service generates JWT token with user claims
\item Token Propagation: Client includes JWT in Authorization headers for all service requests
\item Token Validation: Each service validates JWT signature using shared secret
\item Role Authorization: Services enforce role-based access control based on JWT claims
\item Cross-Service Calls: Services propagate authentication context for chained operations
\end{enumerate}

\textbf{Security Implementation:}
\begin{itemize}
\item JWT tokens with 30-minute expiration and automatic refresh mechanisms
\item Shared secret key across all services for token validation consistency
\item Role-based access control with User and Admin privilege levels
\item CORS configuration enabling secure cross-origin requests from frontend
\item Request/response logging for security audit trails and compliance
\end{itemize}

\subsubsection{Business Transaction Patterns}

The platform implements complex business transactions that span multiple services, demonstrating distributed transaction management and eventual consistency patterns essential for microservices architectures. These patterns showcase real-world operational complexity while providing meaningful data for methodology performance analysis.

\textbf{Order Processing Transaction Flow:}
\begin{enumerate}
\item Cart Validation: Cart Service validates items and calculates totals
\item User Authentication: User Service validates customer identity and permissions
\item Product Verification: Product Service confirms availability and pricing
\item Order Creation: Order Service creates transaction records and manages state
\item Inventory Update: Product Service updates stock levels and availability
\item Payment Processing: Order Service coordinates with external payment providers
\item Fulfillment Initiation: Order Service triggers shipping and tracking processes
\end{enumerate}

\textbf{Data Consistency Management:}
\begin{itemize}
\item Event-driven architecture with service-to-service communication
\item Compensating transaction patterns for rollback scenarios
\item Eventual consistency models with conflict resolution strategies
\item Distributed state management with service ownership boundaries
\item Error handling and retry mechanisms for transaction resilience
\end{itemize}

\subsection{Authentication and Authorization Flow Design}

The authentication and authorization architecture implements a comprehensive security framework that demonstrates enterprise-grade identity management while supporting both user-facing and administrative operations. The design prioritizes security, usability, and operational efficiency while providing detailed audit capabilities for compliance and research analysis.

\subsubsection{JWT Implementation Architecture}

The JWT implementation provides stateless authentication that scales across multiple services and platforms while maintaining security and performance characteristics essential for distributed systems. The token structure includes comprehensive user information and role assignments that enable fine-grained authorization decisions.

\textbf{JWT Token Structure:}
\begin{verbatim}
{
  "sub": "user_id_123",
  "email": "user@example.com", 
  "name": "John Doe",
  "role": "user|admin",
  "iat": 1692123456,
  "exp": 1692125256,
  "jti": "unique_token_id"
}
\end{verbatim}

\textbf{Token Management Features:}
\begin{itemize}
\item Configurable expiration times balancing security with user experience
\item Unique token identifiers (JTI) enabling token revocation and audit trails
\item Role-based claims supporting hierarchical permission models
\item Automatic token refresh mechanisms reducing authentication friction
\item Secure token storage and transmission protocols
\end{itemize}

\subsubsection{Role-Based Access Control Design}

The RBAC implementation provides flexible permission management that supports both operational requirements and administrative functions while maintaining clear security boundaries between different user types and service capabilities.

\textbf{Permission Hierarchy:}
\begin{itemize}
\item Public Access: Service health checks, product browsing, user registration
\item Authenticated User: Profile management, cart operations, order placement, order history
\item Administrative User: User management, product management, order administration, system analytics
\item System Integration: Inter-service communication, health monitoring, operational metrics
\end{itemize}

\textbf{Authorization Enforcement:}
\begin{itemize}
\item Endpoint-level authorization with role requirements clearly documented
\item Service-level authorization for cross-service communication patterns
\item Administrative function protection with enhanced logging and audit trails
\item API documentation with authorization requirements for each endpoint
\end{itemize}

\subsection{User vs Admin Interface Architecture}

The platform architecture supports dual interfaces optimized for different user types and operational requirements, demonstrating sophisticated user experience design while maintaining consistent backend services and security models. This design showcases enterprise-grade application architecture with role-based user experience optimization.

\subsubsection{User Interface Architecture}

The user-facing interface prioritizes ease of use, performance, and conversion optimization while providing comprehensive e-commerce functionality through intuitive workflows and responsive design patterns.

\textbf{User Experience Features:}
\begin{itemize}
\item Product browsing and search with advanced filtering capabilities
\item Shopping cart management with real-time updates and validation
\item User registration and authentication with social login options
\item Order placement with multiple payment methods and shipping options
\item Order tracking with real-time status updates and notifications
\item Profile management with personal information and preference settings
\end{itemize}

\subsubsection{Administrative Interface Architecture}

The administrative interface provides comprehensive platform management capabilities optimized for operational efficiency and business intelligence while maintaining security and audit compliance.

\textbf{Administrative Capabilities:}
\begin{itemize}
\item User management dashboard with registration analytics and user control
\item Product catalog management with inventory tracking and promotional tools
\item Order management system with status updates and fulfillment coordination
\item Business analytics with revenue tracking and performance metrics
\item System monitoring with service health and operational metrics
\item Security management with access control and audit trail review
\end{itemize}

% TODO: Add Table 4.1 - Service Capabilities and Interface Access Matrix
\begin{table}[H]
\centering
\caption{Service Capabilities and User Interface Access Matrix}
\label{tab:service-capabilities-matrix}
% Table content to be added later
\end{table}