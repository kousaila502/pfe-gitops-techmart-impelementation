\chapter{Requirements Analysis}

\section{Introduction and Research Requirements Overview}

This chapter presents a comprehensive analysis of the requirements that guided the design and implementation of the TechMart platform for empirical GitOps versus Traditional CI/CD methodology comparison. The requirements analysis emphasizes the DevOps engineering challenges, architectural decisions, and research infrastructure needs that enable rigorous comparative evaluation while operating within realistic resource constraints.

The requirements analysis process focused on identifying the technical capabilities necessary for conducting valid empirical research while demonstrating production-grade DevOps implementation skills. This dual emphasis on research validity and operational excellence required careful consideration of service distribution strategies, infrastructure optimization, and monitoring capabilities that could provide meaningful comparative data.

The chapter progresses through resource-constrained architecture planning, methodology-specific implementation requirements, multi-cloud service distribution, and empirical research infrastructure needs. Each section demonstrates how practical constraints can be transformed into research opportunities while maintaining technical rigor and operational reliability.

The requirements analysis establishes the foundation for architectural decisions presented in subsequent chapters while highlighting the strategic thinking and resource optimization capabilities essential for real-world DevOps engineering in resource-constrained environments.

\section{Resource-Constrained Architecture Requirements}

\subsection{Budget and Resource Limitation Analysis}

The fundamental constraint driving architectural decisions was the limited budget allocation of \$300 in Google Cloud Platform credits combined with free-tier limitations across multiple cloud providers. This resource constraint necessitated strategic analysis of service placement, resource allocation, and infrastructure optimization to maximize research value while maintaining production-grade implementation standards.

Google Kubernetes Engine resource pricing analysis revealed that deploying all four microservices on GKE would exceed budget constraints due to persistent volume costs, load balancer fees, and compute instance requirements. The cost structure of e2-micro instances with associated networking and storage costs required careful optimization to enable extended research duration within budget limitations.

% TODO: Add Table 3.1 - GKE Cost Analysis and Budget Breakdown
\begin{table}[H]
\centering
\caption{GKE Resource Cost Analysis and Budget Allocation}
\label{tab:gke-budget-analysis}
% Table content to be added later
\end{table}

Heroku platform analysis identified opportunities for cost-effective deployment through free dyno hours, hobby-tier pricing, and educational discounts that could accommodate simpler services with lower resource requirements. The platform-as-a-service model provided reduced operational overhead while offering sufficient capabilities for Traditional CI/CD methodology evaluation.

GitHub Student Pack benefits provided additional resources including enhanced CI/CD minutes, private repository capabilities, and educational access to premium tools that significantly enhanced development and deployment capabilities without additional cost. These educational benefits enabled implementation of sophisticated automation workflows that would otherwise require significant investment.

\subsection{Strategic Service Distribution Requirements}

The resource constraints necessitated strategic analysis of service complexity and infrastructure requirements to optimize placement across available platforms. This analysis required evaluation of each service's computational requirements, data persistence needs, scaling characteristics, and operational complexity to determine optimal deployment strategies.

User Service complexity analysis identified requirements for sophisticated authentication workflows, database connectivity, session management, and security enforcement that would benefit significantly from Kubernetes orchestration capabilities. The service's role as authentication provider for the entire system required high availability, automatic scaling, and comprehensive monitoring that aligned with GitOps automation benefits.

Order Service analysis revealed complex transaction processing requirements, multi-database connectivity (PostgreSQL and Redis), and business logic sophistication that justified investment in GitOps orchestration capabilities. The service's integration requirements and computational complexity made it an ideal candidate for demonstrating GitOps automation and self-healing capabilities.

% TODO: Add Figure 3.1 - Service Complexity vs Platform Capability Matrix
\begin{figure}[H]
\centering
% Figure content to be added later
\caption{Service Complexity Analysis and Platform Assignment Strategy}
\label{fig:service-complexity-matrix}
\end{figure}

Product Service analysis identified relatively straightforward CRUD operations with MongoDB integration that could be efficiently implemented using Heroku's platform-as-a-service model. The service's simpler architecture and predictable resource requirements aligned well with Traditional CI/CD deployment approaches and Heroku's optimization characteristics.

Cart Service evaluation revealed moderate complexity with Redis integration and session management requirements that could benefit from Heroku's managed Redis offerings while demonstrating Traditional CI/CD capabilities. The service's Java Spring Boot implementation aligned well with Heroku's JVM optimization and container deployment capabilities.

\subsection{GitHub Student Pack Resource Optimization}

GitHub Student Pack resources provided substantial enhancements to development and deployment capabilities that enabled implementation of enterprise-grade DevOps practices without financial investment. The educational benefits included expanded GitHub Actions minutes, private repository access, and premium tool integrations that significantly enhanced automation capabilities.

GitHub Actions optimization leveraged educational benefits to implement comprehensive CI/CD workflows for all services without usage limitations that would otherwise constrain automation scope. The enhanced minutes allocation enabled extensive testing, multiple environment deployments, and sophisticated workflow orchestration that demonstrated advanced DevOps automation capabilities.

Private repository capabilities enabled secure code management and collaboration while supporting branch protection policies, code review workflows, and integration with external services. These capabilities provided professional development environments that aligned with enterprise standards while supporting academic research requirements.

Premium tool integrations including monitoring services, security scanning, and deployment platforms provided access to enterprise-grade capabilities that enhanced system reliability and security. These integrations enabled implementation of production-grade operational practices while maintaining cost efficiency through educational pricing.

% TODO: Add Table 3.2 - GitHub Student Pack Resource Utilization
\begin{table}[H]
\centering
\caption{GitHub Student Pack Resource Utilization and Benefits}
\label{tab:github-student-benefits}
% Table content to be added later
\end{table}

\subsection{Hybrid Architecture Opportunity Requirements}

The resource constraints created an unexpected research opportunity by necessitating hybrid architecture implementation that enabled direct comparison of GitOps and Traditional CI/CD methodologies within the same application ecosystem. This hybrid approach provided unique insights into methodology coexistence, integration patterns, and comparative performance characteristics.

Cross-methodology integration requirements included seamless authentication flow between GitOps and Traditional CI/CD services, consistent API standards, shared database access patterns, and unified monitoring approaches. These integration challenges provided valuable research insights while demonstrating advanced system integration capabilities.

Service communication requirements encompassed secure inter-service authentication, consistent error handling, distributed transaction management, and performance optimization across different deployment platforms. The hybrid architecture required sophisticated service mesh patterns and API gateway implementation to ensure reliable communication across methodological boundaries.

Operational consistency requirements included unified logging, monitoring, alerting, and deployment coordination across different platforms and methodologies. This operational integration demonstrated advanced DevOps practices while enabling comprehensive system observability necessary for empirical research validation.

% TODO: Add Figure 3.2 - Hybrid Architecture Integration Patterns
\begin{figure}[H]
\centering
% Figure content to be added later
\caption{Hybrid GitOps-Traditional CI/CD Integration Architecture}
\label{fig:hybrid-architecture-integration}
\end{figure}

The hybrid architecture also provided risk mitigation benefits by distributing services across multiple platforms, reducing single points of failure, and enabling comparative evaluation of platform capabilities under identical workload conditions. This distribution strategy enhanced system resilience while providing comprehensive research data on methodology performance characteristics.

\section{GitOps Implementation Requirements (GKE Services)}

\subsection{ArgoCD Controller and Synchronization Requirements}

ArgoCD implementation requirements encompassed comprehensive GitOps controller deployment that could manage complex application lifecycles while providing automated synchronization capabilities for the User and Order services. The controller architecture required high availability configuration, secure Git repository integration, and sophisticated reconciliation capabilities that could handle complex application dependencies.

Synchronization requirements included real-time Git repository monitoring, automatic manifest application, health status tracking, and rollback capabilities that demonstrated GitOps operational excellence. The synchronization framework needed to handle complex Kubernetes resources including deployments, services, ingress controllers, and persistent volume claims while maintaining consistency across multiple application components.

Git repository integration requirements encompassed secure authentication, webhook configuration, branch management, and pull request workflow integration that enabled collaborative development while maintaining deployment automation. The repository structure needed to support environment-specific configurations, security policies, and deployment strategies through declarative manifest organization.

% TODO: Add Figure 3.3 - ArgoCD Architecture and Git Integration Flow
\begin{figure}[H]
\centering
% Figure content to be added later
\caption{ArgoCD Controller Architecture and Git Repository Integration}
\label{fig:argocd-architecture}
\end{figure}

Application health monitoring requirements included comprehensive readiness and liveness probe configuration, resource utilization tracking, and failure detection capabilities that enabled automated remediation actions. The monitoring framework needed to provide detailed visibility into application status while supporting automated decision-making for scaling and recovery operations.

Automated remediation capabilities required configuration of self-healing policies, automatic rollback procedures, and escalation mechanisms that could respond to various failure scenarios without human intervention. These capabilities demonstrated GitOps operational advantages while providing research data on automation effectiveness and reliability characteristics.

\subsection{Declarative Configuration Management Requirements}

Declarative configuration management required comprehensive Infrastructure as Code implementation that could manage complex Kubernetes resources through version-controlled manifests stored in Git repositories. The configuration framework needed to support environment-specific customizations, security policies, and scaling configurations while maintaining consistency and auditability.

Manifest organization requirements included logical resource grouping, namespace management, secret handling, and configuration templating that enabled maintainable infrastructure definitions. The manifest structure needed to support complex applications with multiple components while providing clear separation of concerns and dependency management.

Kustomize integration requirements encompassed overlay management for environment-specific configurations, patch application for customizations, and resource transformation capabilities that enabled flexible deployment strategies without configuration duplication. The Kustomize framework needed to support development, staging, and production environments with appropriate security and performance configurations.

% TODO: Add Table 3.3 - Declarative Configuration Structure and Organization
\begin{table}[H]
\centering
\caption{Declarative Configuration Management Structure}
\label{tab:declarative-config-structure}
% Table content to be added later
\end{table}

Security policy enforcement requirements included secret management, RBAC configuration, network policies, and container security standards that ensured production-grade security while supporting research data collection needs. The security framework needed to demonstrate enterprise-grade practices while enabling comprehensive system monitoring and analysis.

Configuration validation requirements encompassed syntax validation, policy compliance checking, resource limit enforcement, and dependency verification that prevented deployment of invalid or insecure configurations. The validation framework needed to provide early feedback to development teams while maintaining system stability and security standards.